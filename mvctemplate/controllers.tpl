//Generated by slacker 
//gin router
/*
api.GET("/{{.LowerName}}/:id",controllers.{{.CamelCaseName}}{}.Take)
api.GET("/{{.LowerName}}",controllers.{{.CamelCaseName}}{}.List)
api.POST("/{{.LowerName}}",controllers.{{.CamelCaseName}}{}.Create)
api.PUT("/{{.LowerName}}/:id",controllers.{{.CamelCaseName}}{}.Update)
api.PATCH("/{{.LowerName}}/:id",controllers.{{.CamelCaseName}}{}.Patch)
api.DELETE("/{{.LowerName}}/:id",controllers.{{.CamelCaseName}}{}.Delete) 
api.PATCH("/{{.LowerName}}",controllers.{{.CamelCaseName}}{}.BatchPatch)
api.DELETE("/{{.LowerName}}",controllers.{{.CamelCaseName}}{}.BatchDelete)
api.PUT("/{{.LowerName}}",controllers.{{.CamelCaseName}}{}.BatchUpdate)
importdata.POST("/{{.LowerName}}", controllers.{{.CamelCaseName}}{}.Import)
exportdata.GET("/{{.LowerName}}", controllers.{{.CamelCaseName}}{}.Export)
*/

package controllers

import(
    "{{"gosrc/models"| .ImportLibrary}}"
	"github.com/gin-gonic/gin"
	"net/http"
	"strconv"
)

type {{.CamelCaseName}} struct{ 
}

func (_ {{.CamelCaseName}}) List(c *gin.Context)  {
    var {{.LowerName}} models.{{.CamelCaseName}}
	offset,_:=strconv.ParseUint(c.DefaultQuery("offset","0"), 10, 64)
 
    limit,_:=strconv.ParseUint(c.DefaultQuery("limit","0"),10,64)
 	c.ShouldBindQuery(&{{.LowerName}})
   data,total,err:= {{.LowerName}}.List(offset,limit)
   	if err != nil {
		c.JSON(http.StatusOK, JSON.Error(err))
		return
	}
	c.JSON(http.StatusOK, JSON.OK(gin.H{
		"data":  data,
		"total": total,
	}))
}

func (_ {{.CamelCaseName}}) Take(c *gin.Context)  {
    var {{.LowerName}} models.{{.CamelCaseName}}
		c.ShouldBindQuery(&{{.LowerName}})
    id, err := strconv.ParseInt(c.Param("id"),10,64)
	if err != nil {
		c.JSON(http.StatusOK, JSON.BadRequest())
		return
	}
    {{.LowerName}}.{{.PrimaryKeyColumn.CamelCaseName}}=id
    {{.LowerName}}, err = {{.LowerName}}.Take()
	if err != nil {
		c.JSON(http.StatusOK, JSON.Error(err))
		return
	}
	c.JSON(http.StatusOK, JSON.OK({{.LowerName}}))
}

func (_ {{.CamelCaseName}}) Create(c *gin.Context)  {
    var {{.LowerName}} models.{{.CamelCaseName}}
    if err := c.ShouldBindJSON(&{{.LowerName}}); err != nil {
        c.JSON(http.StatusOK, JSON.BadBinding(err))
        return
	}
    {{.LowerName}},err := {{.LowerName}}.Create()
	if err != nil {
		c.JSON(http.StatusOK, JSON.Error(err))
		return
	}
	c.JSON(http.StatusOK, JSON.OK({{.LowerName}}))
}

func (_ {{.CamelCaseName}}) Update(c *gin.Context)  {
	  id, err := strconv.ParseInt(c.Param("id"),10,64)
	if err != nil {
		c.JSON(http.StatusOK, JSON.BadRequest())
		return
	}
    var {{.LowerName}} models.{{.CamelCaseName}}
	if err := c.ShouldBindJSON(&{{.LowerName}}); err != nil {
		c.JSON(http.StatusOK, JSON.BadBinding(err))
		return
	}
	{{.LowerName}}.{{.PrimaryKeyColumn.CamelCaseName}} = id
	err = {{.LowerName}}.Update()
	if err != nil {
		c.JSON(http.StatusOK, JSON.Error(err))
		return
	}
	c.JSON(http.StatusOK, JSON.OK(nil))
}

func (_ {{.CamelCaseName}}) Patch(c *gin.Context)  {
	id, err := strconv.ParseInt(c.Param("id"),10,64)
	if err != nil {
		c.JSON(http.StatusOK, JSON.BadRequest())
		return
	}
	var updatefields = make(map[string]interface{})
	if err := c.ShouldBindJSON(&updatefields); err != nil {
		c.JSON(http.StatusOK, JSON.BadBinding(err))
		return
	}
	var {{.LowerName}} models.{{.CamelCaseName}}
	{{.LowerName}}.{{.PrimaryKeyColumn.CamelCaseName}} = id
	err = {{.LowerName}}.Patch(updatefields)
	if err != nil {
		c.JSON(http.StatusOK, JSON.Error(err))
		return
	}
	c.JSON(http.StatusOK, JSON.OK(nil))
}

func (_ {{.CamelCaseName}}) Delete(c *gin.Context)  {
    id, err := strconv.ParseInt(c.Param("id"),10,64)
	if err != nil {
		c.JSON(http.StatusOK, JSON.BadRequest())
		return
	}
    var {{.LowerName}} models.{{.CamelCaseName}}
	{{.LowerName}}.{{.PrimaryKeyColumn.CamelCaseName}} = id
	err = {{.LowerName}}.Delete()
	if err != nil {
		c.JSON(http.StatusOK, JSON.Error(err))
		return
	}
	c.JSON(http.StatusOK, JSON.OK(nil))
}


func (_ {{.CamelCaseName}}) BatchDelete(c *gin.Context) {
	ids := strings2int64s(c.QueryArray("id"))
	ids = append(ids, strings2int64s(c.QueryArray("id[]"))...)
	var {{.LowerName}} models.{{.CamelCaseName}}
	err := {{.LowerName}}.BatchDelete(ids)
	if err != nil {
		c.JSON(http.StatusOK, JSON.Error(err))
		return
	}
	c.JSON(http.StatusOK, JSON.OK(nil))
}



func (_ {{.CamelCaseName}}) BatchPatch(c *gin.Context) {
	var updatefields = make(map[string]interface{})
	if err := c.ShouldBindJSON(&updatefields); err != nil {
		c.JSON(http.StatusOK, JSON.BadBinding(err))
		return
	}
	ids := strings2int64s(c.QueryArray("id"))
	ids = append(ids, strings2int64s(c.QueryArray("id[]"))...)
	var {{.LowerName}} models.{{.CamelCaseName}}
	err := {{.LowerName}}.BatchPatch(ids, updatefields)
	if err != nil {
		c.JSON(http.StatusOK, JSON.Error(err))
		return
	}
	c.JSON(http.StatusOK, JSON.OK(nil))
}

func (_ {{.CamelCaseName}}) BatchUpdate(c *gin.Context) {
	var {{.LowerName}} models.{{.CamelCaseName}} 
	if err := c.ShouldBindJSON(&{{.LowerName}}); err != nil {
		c.JSON(http.StatusOK,JSON.BadBinding(err))
		return
	}
	ids := strings2int64s(c.QueryArray("id"))
	ids = append(ids, strings2int64s(c.QueryArray("id[]"))...)
	err := {{.LowerName}}.BatchUpdate(ids)
	if err != nil {
		c.JSON(http.StatusOK, JSON.Error(err))
		return
	}
	c.JSON(http.StatusOK, JSON.OK(nil))
}

func (_ {{.CamelCaseName}}) Import(c *gin.Context) {
	 
	file, err := c.FormFile("file")
	if err != nil {
		c.JSON(http.StatusOK, JSON.Error(err))
		return
	}
	f, err := file.Open()
	if err != nil {
		c.JSON(http.StatusOK, JSON.Error(err))
		return
	}
	b, err := ioutil.ReadAll(f)
	if err != nil {
		c.JSON(http.StatusOK, JSON.Error(err))
		return
	}
	//github.com/tealeg/xlsx
	execl, err := xlsx.OpenBinary(b)
	if err != nil {
		c.JSON(http.StatusOK, JSON.Error(err))
		return
	}
	var {{.LowerName}}s = make([]models.{{.CamelCaseName}}, 0)
	for _, sheet := range execl.Sheets {
		for _, row := range sheet.Rows {
			if len(row.Cells) < 1 {
				continue
			}
			var {{.LowerName}} models.{{.CamelCaseName}}

			{{range $i,$v:=.Columns}}
				{{if eq $v.Type "string"}}
					{{$.LowerName}}.{{$v.CamelCaseName}} = strings.TrimSpace(row.Cells[{{$i}}].String())
				{{end}}

				{{if eq $v.Type "int64"}}
				{{$v.CamelCaseName}},err:= row.Cells[{{$i}}].Int64()
				if err!=nil{
					c.JSON(http.StatusOK, JSON.Error(err))
					return
				}
					{{$.LowerName}}.{{$v.CamelCaseName}} = {{$v.CamelCaseName}}
				{{end}}

				{{if eq $v.Type "int"}}
				{{$v.CamelCaseName}},err:= row.Cells[{{$i}}].Int()
				if err!=nil{
					c.JSON(http.StatusOK, JSON.Error(err))
					return
				}
				{{$.LowerName}}.{{$v.CamelCaseName}} = {{$v.CamelCaseName}}
				{{end}}

				{{if eq $v.Type "bool"}} 
					{{$.LowerName}}.{{$v.CamelCaseName}} = row.Cells[{{$i}}].Bool()
				{{end}}
			{{end}}
			{{.LowerName}}s = append({{.LowerName}}s, {{.LowerName}})
		}
		break
	}
	err = models.{{.CamelCaseName}}{}.Import({{.LowerName}}s)
	if err != nil {
		c.JSON(http.StatusOK, JSON.Error(err))
		return
	}
	c.JSON(http.StatusOK, JSON.OK(nil))
	 
}


func (_ {{.CamelCaseName}}) Export(c *gin.Context) {
		 
	var {{.LowerName}} models.{{.CamelCaseName}} 
	{{.LowerName}}s, _, err := {{.LowerName}}.List(0, 0)
	if err != nil {
		c.String(500, "%v", err.Error())
		return
	}
	var file = xlsx.NewFile()
	sheet, err := file.AddSheet("sheet1")
	if err != nil {
		c.String(500, "%v", err.Error())
		return
	}
	for _, {{.LowerName}} := range {{.LowerName}}s {
		row := sheet.AddRow()
	{{range $i,$v:=.Columns}}
		row.AddCell().SetValue({{$.LowerName}}.{{$v.CamelCaseName}})
	{{end}}
	}
	filename := fmt.Sprintf("{{.Name}}.%v.xlsx", time.Now().Format("20060102150405"))
	c.Header("Content-disposition", "attachment;filename="+filename)
	file.Write(c.Writer)
		 
}