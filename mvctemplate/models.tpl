//Generated by table2struct
//table {{.Name}}
//SQL
//{{.StdSQL}}
//NamedSQL -> github.com/jmoiron/sqlx
//{{.NamedSQL}}
//Columns
//{{.SQLColumns}}
package models

import (
sq	"github.com/Masterminds/squirrel"
)
 
type {{.CamelCaseName}} struct{
    {{range $i,$col:=.Columns}} {{$col.CamelCaseName}} {{$col.Type}} {{$col.Tag}} {{$col.Comment}}
    {{end}}
}


func ({{.Initials}} {{.CamelCaseName}}) List(offset,limit uint64) ([]{{.CamelCaseName}},int,error) {
    var data =make([]{{.CamelCaseName}},0)
    var total int
	var where sq.And
	{{if Contains .SwitchCase "state"}}
		where = append(where, sq.NotEq{"state":StateDel })
	{{end}}
	q, args, _ := sq.Select("count({{.PrimaryKeyColumn.ColumnName}})").From("{{.Name}}").Where(where).ToSql()
    err:=db.Get(&total,q,args...)
    if err!=nil{
        return data,total,err
    }
	builder:= sq.Select("*").From("{{.Name}}").Where(where).OrderBy("{{.PrimaryKeyColumn.ColumnName}} desc")
	if limit>0{
	builder=builder.Limit(limit)
	}
	if offset>0{
	builder=builder.Offset(offset)
	}
	q,args,_ = builder.ToSql()
    err=db.Select(&data,q,args...)
    return data,total,err
}

func ({{.Initials}} {{.CamelCaseName}})Delete()error{
	{{range $i,$col:=.Columns}}
		{{if eq $col.Type "int64"}}
			{{if Contains $col.ColumnName "time"}}
				{{$.Initials}}.{{$col.CamelCaseName}}=time.Now().Unix()
			{{end}}
			{{if Contains $col.ColumnName "update"}}
				{{$.Initials}}.{{$col.CamelCaseName}}=time.Now().Unix()
			{{end}}
		{{end}}
			{{if eq $col.Type "time.Time"}}
			{{$.Initials}}.{{$col.CamelCaseName}}=time.Now()
		{{end}}
	{{end}}

	{{if Contains .SwitchCase "utime"}}
		{{if Contains $.SwitchCase "state"}}
  _,err := db.Exec("update {{$.Name}} set state=?,utime=? where {{$.PrimaryKeyColumn.ColumnName}}=?",StateDel,time.Now().Unix(),{{$.Initials}}.{{$.PrimaryKeyColumn.CamelCaseName}})
		{{else}}
		//_,err := db.Exec("delete from {{$.Name}} where {{.PrimaryKeyColumn.ColumnName}}=?",{{$.Initials}}.{{.PrimaryKeyColumn.CamelCaseName}})
		  _,err := db.Exec("update {{$.Name}} set utime=? where {{$.PrimaryKeyColumn.ColumnName}}=?",time.Now().Unix(),{{$.Initials}}.{{$.PrimaryKeyColumn.CamelCaseName}})
		{{end}}
	{{else}}
	    _,err := db.Exec("delete from {{$.Name}} where {{.PrimaryKeyColumn.ColumnName}}=?",{{$.Initials}}.{{.PrimaryKeyColumn.CamelCaseName}})
	{{end}}
    return err
}

func ({{.Initials}} {{.CamelCaseName}}) Update() error {
	{{range $i,$col:=.Columns}}
		{{if eq $col.Type "int64"}}
			{{if Contains $col.ColumnName "time"}}
				{{$.Initials}}.{{$col.CamelCaseName}}=time.Now().Unix()
			{{end}}
			{{if Contains $col.ColumnName "update"}}
				{{$.Initials}}.{{$col.CamelCaseName}}=time.Now().Unix()
			{{end}}
		{{end}}
			{{if eq $col.Type "time.Time"}}
			{{$.Initials}}.{{$col.CamelCaseName}}=time.Now()
		{{end}}
	{{end}}
    _,err := db.NamedExec("update {{.Name}} set {{.NamedSQL}} where {{.PrimaryKeyColumn.ColumnName}}=:{{.PrimaryKeyColumn.ColumnName}}",{{.Initials}})
    return err
}

func ({{.Initials}} {{.CamelCaseName}}) Patch( update map[string]interface{}) error {
	{{range $i,$col:=.Columns}}
		{{if eq $col.Type "int64"}}
			{{if Contains $col.ColumnName "time"}}
				update["{{$col.ColumnName}}"]=time.Now().Unix()
			{{end}}
			{{if Contains $col.ColumnName "update"}}
				update["{{$col.ColumnName}}"]=time.Now().Unix()
			{{end}}
		{{end}} 

		{{if eq $col.Type "time.Time"}}
			update["{{$col.ColumnName}}"]=time.Now()
		{{end}}
	{{end}} 
	var named []string
	for k := range update {
		switch k {
	   case {{.SwitchCase}}:
			named = append(named, fmt.Sprintf("%s=:%s", k, k))
		}
	}
	if len(named) == 0 {
		return nil
	}
	fields := strings.Join(named, ",")
	update["{{.PrimaryKeyColumn.ColumnName}}"] = {{.Initials}}.{{.PrimaryKeyColumn.CamelCaseName}}
	_, err := db.NamedExec("update {{.Name}} set "+ fields +" where {{.PrimaryKeyColumn.ColumnName}}=:{{.PrimaryKeyColumn.ColumnName}}", update)
	return err
}


func ({{.Initials}} {{.CamelCaseName}}) Take() ({{.CamelCaseName}},error) {
	{{if Contains .SwitchCase "state"}}
	 err:=db.Get(&{{.Initials}},"select * from {{.Name}} where {{.PrimaryKeyColumn.ColumnName}}=? and state!=? limit 1",{{.Initials}}.{{.PrimaryKeyColumn.CamelCaseName}},StateDel)
	{{else}}
    err:=db.Get(&{{.Initials}},"select * from {{.Name}} where {{.PrimaryKeyColumn.ColumnName}}=? limit 1",{{.Initials}}.{{.PrimaryKeyColumn.CamelCaseName}})
	{{end}}
    return {{.Initials}},err
}

func ({{.Initials}} {{.CamelCaseName}}) Create()({{.CamelCaseName}}, error ){
	{{range $i,$col:=.Columns}}
		{{if eq $col.Type "int64"}}
			{{if Contains $col.ColumnName "time"}}
				{{$.Initials}}.{{$col.CamelCaseName}}=time.Now().Unix()
			{{end}}
			{{if Contains $col.ColumnName "update"}}
				{{$.Initials}}.{{$col.CamelCaseName}}=time.Now().Unix()
			{{end}}
		{{end}}
		{{if eq $col.ColumnName "state"}}
			{{$.Initials}}.{{$col.CamelCaseName}}=StateOK
		{{end}}
		{{if eq $col.Type "time.Time"}}
			{{$.Initials}}.{{$col.CamelCaseName}}=time.Now()
		{{end}}
	{{end}} 
    result,err := db.NamedExec("insert into {{.Name}} set {{.NamedSQL}}",{{.Initials}})
	if err!=nil{
		return {{.Initials}},err
	}
	{{.Initials}}.{{.PrimaryKeyColumn.CamelCaseName}},err=result.LastInsertId()
    return {{.Initials}}, err
}

func ({{.Initials}} {{.CamelCaseName}}) BatchUpdate(ids []int64) error { 
	tx, err := db.Beginx()
	if err != nil {
		tx.Rollback()
		return err
	}
	{{range $i,$col:=.Columns}}
		{{if eq $col.Type "int64"}}
			{{if Contains $col.ColumnName "time"}}
				{{$.Initials}}.{{$col.CamelCaseName}}=time.Now().Unix()
			{{end}}
			{{if Contains $col.ColumnName "update"}}
				{{$.Initials}}.{{$col.CamelCaseName}}=time.Now().Unix()
			{{end}}
		{{end}} 
		{{if eq $col.Type "time.Time"}}
			{{$.Initials}}.{{$col.CamelCaseName}}=time.Now()
		{{end}}
	{{end}} 
	for _, id := range ids { 
		{{.Initials}}.{{.PrimaryKeyColumn.CamelCaseName}}=id
		_, err := tx.NamedExec("update {{.Name}} set {{.NamedSQL}} where {{.PrimaryKeyColumn.ColumnName}}=:{{.PrimaryKeyColumn.ColumnName}}",{{.Initials}})
		if err != nil {
			tx.Rollback()
			return err
		}
	}
	err = tx.Commit()
	if err != nil {
		tx.Rollback()
	}
	return err
}

func (_ {{.CamelCaseName}}) BatchPatch(ids []int64, update map[string]interface{}) error {
	{{range $i,$col:=.Columns}}
		{{if eq $col.Type "int64"}}
			{{if Contains $col.ColumnName "time"}}
				update["{{$col.ColumnName}}"]=time.Now().Unix()
			{{end}}
			{{if Contains $col.ColumnName "update"}}
				update["{{$col.ColumnName}}"]=time.Now().Unix()
			{{end}}
		{{end}}
		{{if eq $col.Type "time.Time"}}
			update["{{$col.ColumnName}}"]=time.Now().Unix()
		{{end}}
	{{end}} 
	var named []string
	for k := range update {
		switch k {
	   case {{.SwitchCase}}:
			named = append(named, fmt.Sprintf("%s=:%s", k, k))
		}
	}
	if len(named) == 0 {
		return nil
	}
	fields := strings.Join(named, ",")
	tx, err := db.Beginx()
	if err != nil {
		tx.Rollback()
		return err
	}
	for _, id := range ids {
		update["{{.PrimaryKeyColumn.ColumnName}}"] = id
		_, err := tx.NamedExec("update {{.Name}} set "+ fields +" where {{.PrimaryKeyColumn.ColumnName}}=:{{.PrimaryKeyColumn.ColumnName}}", update)
		if err != nil {
			tx.Rollback()
			return err
		}
	}
	err = tx.Commit()
	if err != nil {
		tx.Rollback()
	}
	return err
}




func (_ {{.CamelCaseName}}) BatchCreate({{.LowerName}}s []{{.CamelCaseName}}) error {
	tx, err := db.Beginx()
	if err != nil {
		tx.Rollback()
		return err
	}
	stmt, err := tx.PrepareNamed("insert into {{.Name}} set {{.NamedSQL}}")
	if err != nil {
		tx.Rollback()
		return err
	} 
	defer stmt.Close()
	for _, {{.LowerName}} := range {{.LowerName}}s { 
	{{range $i,$col:=$.Columns}}
		{{if eq $col.Type "int64"}}
			{{if Contains $col.ColumnName "time"}}
				{{$.LowerName}}.{{$col.CamelCaseName}}=time.Now().Unix()
			{{end}}
			{{if Contains $col.ColumnName "update"}}
				{{$.LowerName}}.{{$col.CamelCaseName}}=time.Now().Unix()
			{{end}}
		{{end}}
		{{if eq $col.Type "time.Time"}}
			{{$.LowerName}}.{{$col.CamelCaseName}}=time.Now()
		{{end}}
	{{end}} 
		_, err := stmt.Exec({{.LowerName}})
		if err != nil {
			tx.Rollback()
			return err
		}
	}
	err = tx.Commit()
	if err != nil {
		tx.Rollback()
	}
	return err
}

 

func (_ {{.CamelCaseName}})BatchDelete(ids []int64)error{
    tx, err := db.Beginx()
	if err != nil {
		tx.Rollback()
		return err
	}
	for _, id := range ids {
	{{if Contains .SwitchCase "utime"}}
		{{if Contains $.SwitchCase "state"}}
		_, err := tx.Exec("update {{.Name}} set state=?,utime=? where {{.PrimaryKeyColumn.ColumnName}}=?",StateDel,time.Now().Unix(),id)
		{{else}}
		_, err := tx.Exec("update {{.Name}} set utime=? where {{.PrimaryKeyColumn.ColumnName}}=?",time.Now().Unix(),id)
		{{end}}
	{{else}}
	_, err := tx.Exec("delete from {{.Name}} where {{.PrimaryKeyColumn.ColumnName}}=?",id)
	{{end}}
		if err != nil {
			tx.Rollback()
			return err
		}
	}
	err = tx.Commit()
	if err != nil {
		tx.Rollback()
	}
	return err
}


func (_ {{.CamelCaseName}}) Import({{.LowerName}}s []{{.CamelCaseName}}) error {
	tx, err := db.Beginx()
	if err != nil {
		tx.Rollback()
		return err
	}
	stmt, err := tx.PrepareNamed("insert into {{.Name}} set {{.NamedSQL}}")
	if err != nil {
		tx.Rollback()
		return err
	} 
	defer stmt.Close()

	_, err = tx.Exec("truncate table {{.Name}}")
	if err != nil {
		tx.Rollback()
		return err
	} 


	for _, {{.LowerName}} := range {{.LowerName}}s { 
	{{range $i,$col:=$.Columns}}
		{{if eq $col.Type "int64"}}
			{{if Contains $col.ColumnName "time"}}
				{{$.LowerName}}.{{$col.CamelCaseName}}=time.Now().Unix()
			{{end}}
			{{if Contains $col.ColumnName "update"}}
				{{$.LowerName}}.{{$col.CamelCaseName}}=time.Now().Unix()
			{{end}}
		{{end}} 
		{{if eq $col.Type "time.Time"}}
				{{$.LowerName}}.{{$col.CamelCaseName}}=time.Now()
		{{end}}
	{{end}} 
		_, err := stmt.Exec({{.LowerName}})
		if err != nil {
			tx.Rollback()
			return err
		}
	}
	err = tx.Commit()
	if err != nil {
		tx.Rollback()
	}
	return err
}